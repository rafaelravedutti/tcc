/* Fake iteration */
fn fake_iterate(img : image_struct, body : fn(int, int) -> ()) -> () {
  /* Does nothing */
  body(0, 0);
}

/* Cache size */
fn get_cpu_cache_size() -> int {
  3072 * 1024
}

/* Stencil iterate block size */
fn get_default_iterate_block_size() -> int {
  8
}

/* Stencil iterate block size */
fn get_stencil_iterate_block_size() -> int {
  10
}

/* Sobel iterate block size */
fn get_gradient_iterate_block_size() -> int {
  7 
}

/* Image offset */
fn get_image_offset(img : image_struct) -> i32 {
  img.width * 2 + 5
}

/* Allocate image on device */
fn alloc_gpu_image(img : image_struct) -> Buffer {
  /* Does nothing */
  let mut tmp : Buffer;
  tmp.device = 0;
  tmp
}

/* Upload image */
fn upload_image(img : image_struct) -> () {
  /* Does nothing */
}

/* Get offsets */
fn get_offsets() -> Buffer {
  let offsets = [ 1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 0.0f,  
                  1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f    ];

  let offsets_cpu = alloc_cpu(14 * sizeof[f32]());

  for i in range(0, 13) { 
    write(offsets_cpu, i, offsets(i));
  }
  
  offsets_cpu
}

/* Iterate over image on CPU architectures */
fn block_iterate(img : image_struct, block_size : i32, body : fn(int, int, int) -> ()) -> () {
  let offset = get_image_offset(img);;

  for i in parallel(2, 0, (img.height - (block_size + 1)) / block_size) {
    for j in step_range(0, img.width - (block_size + 1), block_size) {
      for k in range(0, block_size - 1) {
        for l in vectorize(8, 4, 0, block_size - 1) @{
          let x = j + l;
          let y = i * block_size + k;

          body(x + offset, y, x);
        }
      }
    }
  }

  for i in range(img.width - block_size, img.width - 1) {
    for j in range(0, img.height - 1) {
      body(i + offset, j, i);
    }
  }

  for i in range(img.height - block_size, img.height - 1) {
    for j in range(0, img.width - (block_size + 1)) {
      body(j + offset, i, j);
    }
  }
}

fn iterate(img : image_struct, serial : bool, body : fn(int, int) -> ()) -> () {
  let block_size = get_default_iterate_block_size();
  let offset = get_image_offset(img);

  if serial {
    for y in range(0, img.height - 1) {
      for x in range(0, img.width - 1) {
        body(x + offset, y);
      }
    }
  } else {
    for x, y, realx in block_iterate(img, block_size) @{
      body(x, y);
    }
  }
}

fn stencil_iterate(
  img : image_struct,
  filter : filter_struct,
  buffer_to_data : bool,
  body : fn(int, int, Buffer, Buffer, Buffer) -> ()) -> () {
  let mut arr_in : Buffer;
  let mut arr_out : Buffer;

  if buffer_to_data {
    arr_in = img.buffer;
    arr_out = img.data;
  } else {
    arr_in = img.data;
    arr_out = img.buffer;
  }

  for x, y, realx in block_iterate(img, get_stencil_iterate_block_size()) @{
    body(x, y, arr_in, arr_out, filter.data);
  }
}

fn gradient_iterate(
  img : image_struct,
  buffer_to_data : bool,
  copy_magnitudes : bool,
  load_image : bool,
  body: fn(int, int, int, Buffer, Buffer, Buffer, Buffer) -> ()) -> () {
  let mut arr_in : Buffer;
  let mut arr_out : Buffer;

  if buffer_to_data {
    arr_in = img.buffer;
    arr_out = img.data;
  } else {
    arr_in = img.data;
    arr_out = img.buffer;
  }

  for x, y, realx in block_iterate(img, get_gradient_iterate_block_size()) @{
    body(x, y, realx, arr_in, arr_out, img.dx, img.dy);
  }
}

fn write(buf : Buffer, i : i32, v : f32) -> () {
  (buf.data as &mut[f32])(i) = v
}

fn read(buf : Buffer, i : i32) -> f32 {
  (buf.data as &mut[f32])(i)
}

fn release_image_from_device(img : image_struct) -> () {
  release(img.offsets);
}

/* Base-e exponential function */
fn exp(a : f32) -> (f32) {
  cpu_intrinsics.expf(a)
}
