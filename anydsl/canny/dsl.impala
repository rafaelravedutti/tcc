/* Image data structure */
struct image_struct {
  image : &mut[f32],          /* Image data */
  width : i32,                /* Image width */
  height : i32,               /* Image height */
  data: Buffer,               /* Data with increased dimensions */
  buffer: Buffer,             /* Buffer with increased dimensions */
  dx : Buffer,                /* Gx matrix */
  dy : Buffer,                /* Gy matrix */
  gpu_data : Buffer,          /* Data at GPU */
  gpu_buffer : Buffer,        /* Buffer at GPU */
  gpu_dx : Buffer,            /* Gx matrix at GPU */
  gpu_dy : Buffer,            /* Gy matrix at GPU */
  offsets : Buffer            /* Offsets at GPU */
};

/* Filter data structure */
struct filter_struct {
  data : Buffer,              /* Filter coefficients */
  size : i32                  /* Filter size */
};

/* Functions implemented in C/C++ files */
extern "C" {
  /* Display usage function */
  fn display_usage(command : &[u8]) -> ();

  /* OpenCV functions for result comparison */
  fn opencv_gaussian(
    img : &mut[f32], mask_size : u8, display : bool
  ) -> (&mut[f32]);
  fn opencv_sobel(
    img : &mut[f32], sx : i32, sy : i32, aperture_size : i32, display : bool
  ) -> (&mut[f32]);
  fn opencv_canny(
    filename : &[u8], low_threshold : f32, high_threshold: f32, opencv_time : &f64
  ) -> (&mut[f32]);

  /* OpenCV utils */
  fn load_image(path : &[u8], width : &i32, height : &i32) -> (&mut[f32]);
  fn display_image(img : &mut[f32], title : &[u8], wait : bool) -> ();
  fn write_image(img : &mut[f32], title : &[u8]) -> ();

  /* Stack functions */
  fn stack_init() -> ();
  fn push_conditional(x : i32, y : i32, condition : i32) -> ();
  fn pop(x : &i32, y : &i32) -> i32;

  /* Time */
  fn impala_time() -> f64;

  /* Printing functions */
  fn show_statistics(
    corrects : i32, false_positives : i32, false_negatives : i32
  ) -> ();
  fn show_profile_statistics(
    gaussian_time : f64, sobel_time : f64, nms_time : f64, hysteresis_time : f64
  ) -> ();
  fn show_time_statistics(first_time : f64, second_time : f64) -> ();
}

/* Load image form file and saves it into a image_struct structure */
fn image(filename : &[u8]) -> image_struct {
  let mut res : image_struct;     /* Image structure to store the image */
  let pwidth = &mut res.width;    /* Pointer to width */
  let pheight = &mut res.height;  /* Pointer to height */
  let acc = cuda_accelerator(0);

  /* Loads image using OpenCV */
  res.image = load_image(filename, pwidth, pheight);

  /* Stores the image to structure data */
  res.data = alloc_cpu((res.width + 4) * (res.height + 4) * sizeof[f32]());

  /* Knowing its size, allocates the buffer and directions pointers */
  res.buffer = alloc_cpu((res.width + 4) * (res.height + 4) * sizeof[f32]());

  /* Allocate Sobel directions */
  res.dx = alloc_cpu((res.width + 4) * (res.height + 4) * sizeof[f32]());
  res.dy = alloc_cpu((res.width + 4) * (res.height + 4) * sizeof[f32]());

  /* Copy image content to data */
  copy_image_to_data(res.image, res);

  /* GPU */
  res.gpu_data = acc.alloc((res.width + 4) * (res.height + 4) * sizeof[f32]());
  res.gpu_buffer = acc.alloc((res.width + 4) * (res.height + 4) * sizeof[f32]());
  res.gpu_dx = acc.alloc((res.width + 4) * (res.height + 4) * sizeof[f32]());
  res.gpu_dy = acc.alloc((res.width + 4) * (res.height + 4) * sizeof[f32]());
  res.offsets = acc.alloc(14 * sizeof[f32]());

  /* Offsets for the angles */
  let offsets = [ 1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 
                  1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f    ];

  let offsets_cpu = alloc_cpu(14 * sizeof[f32]());

  for off in range(0, 13) {
    write(offsets_cpu, off, offsets(off));
  }

  copy(offsets_cpu, res.offsets, 14 * sizeof[f32]());
  copy(res.data, res.gpu_data, (res.width + 4) * (res.height + 4) * sizeof[f32]());

  for x, y in fake_iterate(res) {
    /* Only to compile cuda kernels */
  }

  res
}

/* Destroys image structure to free memory space */
fn destroy_image(img : image_struct) -> () {
  /* Release image data from device */
  release_image_from_device(img);

  /* Free buffer and directions pointers */
  release(img.data);
  release(img.buffer);
  release(img.dx);
  release(img.dy);
}

/* Copies OpenCV loaded image to image structure data */
fn copy_image_to_data(image : &mut[f32], img : image_struct) -> () {
  let offset = img.width * 2 + 5;

  for x in range(0, img.width - 1) {
    for y in range(0, img.height - 1) {
      write(img.data, y * img.width + x + offset, image(y * img.width + x));
    }
  }
}

/* Copies image structure data to OpenCV matrix */
fn copy_data_to_image(img : image_struct, image : &mut[f32]) -> () {
  let offset = img.width * 2 + 5;

  for x in range(0, img.width - 1) {
    for y in range(0, img.height - 1) {
      image(y * img.width + x) = read(img.data, y * img.width + x + offset);
    }
  }
}

/* Copies image structure buffer to OpenCV matrix */
fn copy_buffer_to_image(img : image_struct, image : &mut[f32]) -> () {
  let offset = img.width * 2 + 5;

  for x in range(0, img.width - 1) {
    for y in range(0, img.height - 1) {
      image(y * img.width + x) = read(img.buffer, y * img.width + x + offset);
    }
  }
}

/* Iterates from min to max executing the higher-order function specified */
fn range(mut min : i32, max : i32, body : fn(int) -> ()) -> () {
  while min <= max {
    body(min);
    min++;
  }
}

/* Iterates from min to max executing the higher-order function specified */
fn step_range(mut min : i32, max : i32, step : i32, body : fn(int) -> ()) -> () {
  while min <= max {
    body(min);
    min += step;
  }
}

/* Absolute function for integer */
fn abs(a : i32) -> (i32) {
  a * ((a >= 0) as i32) +
  (-a) * ((a < 0) as i32)
}

/* Generates a 5x1f filter data structure given its coefficients */
fn filter_5x1f(mask : [f32 * 5]) -> filter_struct {
  /* Allocates the filter data structure for a 5x1f filter */
  let result = filter_struct {
    data: alloc_cpu(5 * sizeof[f32]()),
    size: 5
  };

  /* Stores the coefficients to the filter data */
  for i in range(0, 4) {
    write(result.data, i, mask(i));
  }

  result
}

/* Apply 2D filter convolution with separable kernels (tiling) */
fn apply_2d_row_convolution(img : image_struct, filter : filter_struct) -> () {
  /* Applies the filter in columns */
  for x, y, arr_in, arr_out, mask in @stencil_iterate(img, filter, false) {
    write(arr_out, y * img.width + x, 0.0f);

    for i in @range(-2, 2) {
      write(arr_out, y * img.width + x,
        read(arr_out, y * img.width + x) +
        read(mask, i + 2) * read(arr_in, y * img.width + x + i)
      );
    }
  }
}

/* Apply 2D filter convolution with separable kernels (tiling) */
fn apply_2d_column_convolution(img : image_struct, filter : filter_struct) -> () {
  /* Applies the filter in rows */
  for x, y, arr_in, arr_out, mask in @stencil_iterate(img, filter, true) {
    write(arr_out, y * img.width + x, 0.0f);

    for i in @range(-2, 2) {
      write(arr_out, y * img.width + x,
        read(arr_out, y * img.width + x) +
        read(mask, i + 2) * read(arr_in, (y + i) * img.width + x)
      );
    }
  }
}

/* Gaussian filter */
fn gaussian_blur(img : image_struct) -> () {
  /* Generates the separable Gaussian kernel based on the
     OpenCV source code */
  let mut mask_xy : [[f32 * 5] * 5];
  let mut mask_x : [f32 * 5];
  let mut mask_y : [f32 * 5];
  let mut sum_x = 0.0f;
  let mut sum_y = 0.0f;
  let anchor = 2.0f;
  let pi = 3.14159f;
  let sigma = 1.1f;
  let prod = 1.0f / (2.0f * pi * sigma * sigma);
  let denom = 2.0f * sigma * sigma;

  for i in range(0, 4) {
    let x = (i as f32) - anchor;

    for j in range(0, 4) {
      let y = (j as f32) - anchor;

      mask_xy(i)(j) = prod * exp(-((x * x + y * y) / denom));
    }

    mask_x(i) = exp(-((x * x) / denom));
    mask_y(i) = exp(-((x * x) / denom));
    sum_x += mask_x(i);
    sum_y += mask_y(i);
  }

  sum_x = 1.0f / sum_x;
  sum_y = 1.0f / sum_y;

  for i in range(0, 4) {
    mask_x(i) *= sum_x;
    mask_y(i) *= sum_y;
  }

  apply_2d_row_convolution(img, filter_5x1f(mask_x));
  apply_2d_column_convolution(img, filter_5x1f(mask_y));
}

/* Sobel filter */
fn sobel(img : image_struct) -> () {
  for x, y, arr_in, arr_out, dx, dy in @gradient_iterate(img, false, false, false) {
    /* dx(x,y) = 0.0f */
    write(dx, y * img.width + x, 0.0f);

    /* dx(x,y) -= arr_in(x - 1, y - 1) */
    write(dx, y * img.width + x,
      read(dx, y * img.width + x) -
      read(arr_in, (y - 1) * img.width + (x - 1))
    );

    /* dx(x,y) -= arr_in(x - 1, y) * 2.0f */
    write(dx, y * img.width + x,
      read(dx, y * img.width + x) -
      read(arr_in, y * img.width + (x - 1)) * 2.0f
    );

    /* dx(x,y) -= arr_in(x - 1, y + 1) */
    write(dx, y * img.width + x,
      read(dx, y * img.width + x) -
      read(arr_in, (y + 1) * img.width + (x - 1))
    );

    /* dx(x,y) += arr_in(x + 1, y - 1) */
    write(dx, y * img.width + x,
      read(dx, y * img.width + x) +
      read(arr_in, (y - 1) * img.width + (x + 1))
    );

    /* dx(x,y) += arr_in(x + 1, y) * 2.0f */
    write(dx, y * img.width + x,
      read(dx, y * img.width + x) +
      read(arr_in, y * img.width + (x + 1)) * 2.0f
    );

    /* dx(x,y) += arr_in(x + 1, y + 1) */
    write(dx, y * img.width + x,
      read(dx, y * img.width + x) +
      read(arr_in, (y + 1) * img.width + (x + 1))
    );

    /* dy(x,y) = 0.0f */
    write(dy, y * img.width + x, 0.0f);

    /* dy(x,y) -= arr_in(x - 1, y - 1) */
    write(dy, y * img.width + x,
      read(dy, y * img.width + x) -
      read(arr_in, (y - 1) * img.width + (x - 1))
    );

    /* dy(x,y) -= arr_in(x, y - 1) * 2.0f */
    write(dy, y * img.width + x,
      read(dy, y * img.width + x) -
      read(arr_in, (y - 1) * img.width + x) * 2.0f
    );

    /* dy(x,y) -= arr_in(x + 1, y - 1) */
    write(dy, y * img.width + x,
      read(dy, y * img.width + x) -
      read(arr_in, (y - 1) * img.width + (x + 1))
    );

    /* dy(x,y) += arr_in(x - 1, y + 1) */
    write(dy, y * img.width + x,
      read(dy, y * img.width + x) +
      read(arr_in, (y + 1) * img.width + (x - 1))
    );

    /* dy(x,y) += arr_in(x, y + 1) * 2.0f */
    write(dy, y * img.width + x,
      read(dy, y * img.width + x) +
      read(arr_in, (y + 1) * img.width + x) * 2.0f
    );

    /* dy(x,y) += arr_in(x + 1, y + 1) */
    write(dy, y * img.width + x,
      read(dy, y * img.width + x) +
      read(arr_in, (y + 1) * img.width + (x + 1))
    );

    /* Boundary condition */
    let condition = (
      (x > img.width * 2 + 5 && x < img.width * 3 + 4) &&
      (y > 1 && y < img.height - 2)
    ) as f32;

    /* dx(x,y) = dx(x,y) * condition */
    write(dx, y * img.width + x,
      read(dx, y * img.width + x) * condition
    );

    /* dy(x,y) = dy(x,y) * condition */
    write(dy, y * img.width + x,
      read(dy, y * img.width + x) * condition
    );

    /* arr_out(x,y) = dx(x,y) * dx(x,y) + dy(x,y) * dy(x,y) */
    write(arr_out, y * img.width + x,
      read(dx, y * img.width + x) * read(dx, y * img.width + x) +
      read(dy, y * img.width + x) * read(dy, y * img.width + x)
    );
  }
}

/* Non-maximum suppression */
fn non_maximum_suppression(
  img : image_struct,
  low_threshold : f32,
  high_threshold : f32
) -> () {
  /* Go through the image */
  for x, y, arr_in, arr_out, dx, dy in @gradient_iterate(img, true, true, true) {
    let pos = y * img.width + x;
    let xs = read(dx, pos) as i32;
    let ys = read(dy, pos) as i32;
    let mx = abs(xs);
    let my = abs(ys) << 15;

    let tg22x = mx * 13573;
    let tg67x = tg22x + (mx << 16);

    let cond1 = (my < tg22x) as i32;
    let cond2 = (my > tg67x) as i32;
    let cond3 = (xs ^ ys < 0) as i32;

    let index = (cond1 << 2) + (cond2 << 1) + cond3;
    let nb1_x = x + (read(img.offsets, index * 2) as i32);
    let nb1_y = y + (read(img.offsets, index * 2 + 1) as i32);
    let nb2_x = x - (read(img.offsets, index * 2) as i32);
    let nb2_y = y - (read(img.offsets, index * 2 + 1) as i32); 

    let nb1_cond = (
      read(arr_in, pos) > read(arr_in, nb1_y * img.width + nb1_x)
    ) as f32;

    let nb2_cond = (
      read(arr_in, pos) > read(arr_in, nb2_y * img.width + nb2_x)
    ) as f32;

    /*
      If the pixel value is less or equal than one of the neighboors' values,
      it's not the local maximum so sets it to zero,

      If not, use the following conditions:
      
      - If pixel value is in the [0,low_threshold] interval, it
      becomes 0 (not an edge)

      - If pixel value is in the ]low_threshold,high_threshold] interval,
      it becomes 1 (weak edge)

      - If pixel value is in the ]high_threshold, 255f[ interval, it becomes
      15 (strong edge) 
    */

    write(arr_out, y * img.width + x, (
      (((read(arr_in, pos) > low_threshold) as f32) * 1.0f) + 
      (((read(arr_in, pos) > high_threshold) as f32) * 14.0f)
    ) * nb1_cond * nb2_cond);
  }
}

/* Hysteresis */
fn hysteresis(img : image_struct) -> () {
  /* Initialize the stack */
  stack_init();

  /* Push weak edges to the stack */
  for x, y in serial_iterate(img) {
    let value = read(img.data, y * img.width + x);

    push_conditional(x, y, 
                      (value > 0.5f && value < 1.5f) as i32);
  }

  /* Go through the image and looks for the weak edges to see if they
     have strong edges as neighboors, if that's the case, they are
     considered edges and are set as strong edges. This procedure is
     executed repeatedly until there are no more weak edges to be updated. */
  let mut x = 0;
  let mut y = 0;

  while pop(&mut x, &mut y) != 0 {
    let weak_condition = (
      read(img.data, y * img.width + x) > 0.5f &&
      read(img.data, y * img.width + x) < 1.5f
    ) as f32;

    let mut sum = 0.0f;

    for i in range(-1, 1) {
      for j in range(-1, 1) {
        sum += read(img.data, (y + j) * img.width + x + i);
      }
    }

    sum *= weak_condition;

    let sum_condition = ((sum > 10.0f) as i32);

    write(img.data, y * img.width + x,
      read(img.data, y * img.width + x) + (sum_condition as f32) * 14.0f);

    for i in range(-1, 1) {
      for j in range(-1, 1) {
        let nb_value = read(img.data, (y + j) * img.width + x + i);
        let nb_weak_condition = (nb_value > 0.5f && nb_value < 1.5f) as i32;

        push_conditional(x + i, y + j, sum_condition & nb_weak_condition);
      }
    }
  }

  /* Sets strong edges pixels to 255f and other pixels to 0 to
     get the final result */
  for x, y in serial_iterate(img) {
    write(img.data, y * img.width + x, 
      ((read(img.data, y * img.width + x) > 10.0f) as f32) * 255.0f);
  }
}

/* Canny */
fn canny(img : image_struct, low_threshold : f32, high_threshold: f32) -> () {
  let gaussian_time = impala_time();
  gaussian_blur(img);
  let sobel_time = impala_time();
  sobel(img);
  let nms_time = impala_time();
  non_maximum_suppression(img,
    low_threshold * low_threshold,
    high_threshold * high_threshold
  );
  let hysteresis_time = impala_time();
  hysteresis(img);

  show_profile_statistics(
    sobel_time - gaussian_time,
    nms_time - sobel_time,
    hysteresis_time - nms_time,
    impala_time() - hysteresis_time
  );
}

/* Compare the result with the reference (OpenCV Canny) and display
   the statistics */
fn compare_results(img : image_struct, reference : &mut[f32]) -> () {
  let mut corrects = 0;
  let mut false_positives = 0;
  let mut false_negatives = 0;
  let uchar_reference = reference as &mut[u8];
  let offset = img.width * 2 + 5;

  for x in range(0, img.width - 1) {
    for y in range(0, img.height - 1) {
      let pixel_value = read(img.data, y * img.width + x + offset) as i32;
      let pixel_reference = uchar_reference(y * img.width + x) as i32;

      write(img.data, y * img.width + x + offset, 0.0f);
      write(img.buffer, y * img.width + x + offset, 0.0f);

      if pixel_value != 0 {
        if pixel_reference != 0 {
          corrects++;
        } else {
          write(img.data, y * img.width + x + offset, 255.0f);
          false_positives++;
        }
      } else if pixel_reference != 0 {
        write(img.buffer, y * img.width + x + offset, 255.0f);
        false_negatives++;
      }
    }
  }

  show_statistics(corrects, false_positives, false_negatives);
}
