/* Image data structure */
struct image_struct {
  data : &mut[u8],        /* Image data */
  oper_buffer : &mut[u8], /* Auxiliary buffer */
  directions : &mut[f64], /* Directions matrix */
  width : i32,            /* Image width */
  height : i32,           /* Image height */
  loaded : bool           /* Is the image data loaded from a file? */
};

/* Filter data structure */
struct filter_struct {
  data : &mut[f64],       /* Filter coefficients */
  size : i32,             /* Filter size */
};

/* Functions implemented in C/C++ files */
extern "C" {
  /* Memory allocation functions */
  fn allocate_double_matrix(width : i32, height : i32) -> (&mut[f64]);
  fn allocate_uchar_matrix(width : i32, height : i32) -> (&mut[u8]);
  fn free_double_matrix(&mut[f64]) -> ();
  fn free_uchar_matrix(image : &[u8]) -> ();

  /* OpenCV functions */
  fn load_image(path : &[u8], width : &i32, height : &i32) -> (&mut[u8]);
  fn opencv_gaussian(img : &mut[u8], mask_size : u8, display : bool) -> (&mut[u8]);
  fn opencv_canny(img : &mut[u8], threshold : u8, display : bool) -> (&mut[u8]);
  fn display_image(img : &mut[u8], title : &[u8], wait : bool) -> ();
  fn write_image(img : &mut[u8], title : &[u8]) -> ();

  /* Printing functions */
  fn print_uchar_matrix(&[u8], width : i32, height : i32) -> ();
  fn print_integer(value : i32) -> ();
  fn print_angle_test(angle : f64, result : i32) -> ();
  fn show_statistics(corrects : i32, false_positives : i32, false_negatives : i32) -> ();
}

/* Load image form file and saves it into a image_struct structure */
fn image(filename : &[u8]) -> image_struct {
  let mut res : image_struct;     /* Image structure to store the image */
  let pwidth = &mut res.width;    /* Pointer to width */
  let pheight = &mut res.height;  /* Pointer to height */

  /* Loads image and stores to the structure */
  res.data = load_image(filename, pwidth, pheight);

  /* Knowing its size, allocates the oper_buffer and directions pointers */
  res.oper_buffer = allocate_uchar_matrix(res.width, res.height);
  res.directions = allocate_double_matrix(res.width, res.height);

  /* Set image as loaded */
  res.loaded = true;

  res
}

/* Generates an image given its dimension (used for synthetical image experiments) */
fn generate_image(width : i32, height : i32) -> image_struct {
  let res = image_struct {
    data: allocate_uchar_matrix(width, height),
    oper_buffer: allocate_uchar_matrix(width, height),
    directions: allocate_double_matrix(width, height),
    width: width,
    height: height,
    loaded: false
  };

  for x, y in iterate(res) {
    set_pixel(res, x, y, (x + y) as u8);
  }

  res
}

/* Prints image data (used for synthetical image experiments) */
fn print_image(img : image_struct) -> () {
  print_uchar_matrix(img.data, img.width, img.height);
}

/* Destroys image structure to free memory space */
fn destroy_image(img : image_struct) -> () {
  /* If the image is loaded, then doesn't free its data (it must be free
     after the cv::Mat destructor call) */
  if !img.loaded {
    free_uchar_matrix(img.data);
  }

  /* Free oper_buffer and directions pointers */
  free_uchar_matrix(img.oper_buffer);
  free_double_matrix(img.directions);
}

/* Sets image pixel at (x, y) coordinates */
fn set_pixel(img : image_struct, x : i32, y : i32, value : u8) -> () {
  img.data(y * img.width + x) = value;
}

/* Gets image pixel at (x, y) coordinates */
fn get_pixel(img : image_struct, x : i32, y : i32) -> (u8) {
  img.data(y * img.width + x)
}

/* Sets image pixel at (x, y) coordinates to f64 (double) value */
fn set_pixel_real(img : image_struct, x : i32, y : i32, value : f64) -> () {
  img.data(y * img.width + x) = value as u8;
}

/* Gets image pixel at (x, y) coordinates as f64 (double) value */
fn get_pixel_real(img : image_struct, x : i32, y : i32) -> (f64) {
  img.data(y * img.width + x) as f64
}

/* Sets oper_buffer pixel at (x, y) coordinates */
fn set_buffer_pixel(img : image_struct, x : i32, y : i32, value : u8) -> () {
  img.oper_buffer(y * img.width + x) = value;
}

/* Gets oper_buffer pixel at (x, y) coordinates */
fn get_buffer_pixel(img : image_struct, x : i32, y : i32) -> (u8) {
  img.oper_buffer(y * img.width + x)
}

/* Sets oper_buffer pixel at (x, y) coordinates to f64 (double) value */
fn set_buffer_pixel_real(img : image_struct, x : i32, y : i32, value : f64) -> () {
  img.oper_buffer(y * img.width + x) = value as u8;
}

/* Gets oper_buffer pixel at (x, y) coordinates as f64 (double) value */
fn get_buffer_pixel_real(img : image_struct, x : i32, y : i32) -> (f64) {
  img.oper_buffer(y * img.width + x) as f64
}

/* Copies oper_buffer data to image data */
fn sync_image_data(img : image_struct) -> () {
  for x, y in iterate(img) {
    img.data(y * img.width + x) = img.oper_buffer(y * img.width + x);
  }
}

/* Copies image data to oper_buffer data */
fn sync_image_buffer(img : image_struct) -> () {
  for x, y in iterate(img) {
    img.oper_buffer(y * img.width + x) = img.data(y * img.width + x);
  }
}

/* Copies data in matrix type to image structure data */
fn copy_data_to_image(img : image_struct, data : &mut[u8]) -> () {
  for x, y in iterate(img) {
    img.data(y * img.width + x) = data(y * img.width + x);
  }
}

/* Converts radian to degrees */
fn radian_to_degrees(angle : f64) -> (f64) {
  angle * 180.0 / 3.14
}

/* Converts degrees to radian */
fn degrees_to_radian(angle : f64) -> (f64) {
  angle * 3.14 / 180.0
}

/* Performs angle roundness and returns the index to its offsets (non-maximum supression) */
fn round_angle(angle : f64) -> (i32) {
  /* In angles: ((abs(angle) + 22.5) / 45) % 4 */
  (((fabs(angle) + 0.3926875) / 0.785375) as i32) % 4
}

/* Executes round_angle function for an angle and prints its result */
fn test_round_angle(angle : f64) -> () {
  print_angle_test(radian_to_degrees(angle), round_angle(angle));
}


/* Iterates from min to max executing the higher-order function specified */
fn range(mut min : i32, max : i32, body : fn(int) -> ()) -> () {
  while min <= max {
    body(min);
    min++;
  }
}

/* Generates a 3x3 filter data structure given its coefficients */
fn filter_3x3(mask : [[f64 * 3] * 3]) -> filter_struct {
  /* Allocates the filter data structure for a 3x3 filter */
  let result = filter_struct {
    data: allocate_double_matrix(3, 3),
    size: 3
  };

  /* Stores the coefficients to the filter data */
  for i in range(0, 2) {
    for j in range(0, 2) {
      result.data((i * 3) + j) = mask(i)(j);
    }
  }

  result
}

/* Generates a 5x5 filter data structure given its coefficients */
fn filter_5x5(mask : [[f64 * 5] * 5]) -> filter_struct {
  /* Allocates the filter data structure for a 5x5 filter */
  let result = filter_struct {
    data: allocate_double_matrix(5, 5),
    size: 5
  };

  /* Stores the coefficients to the filter data */
  for i in range(0, 4) {
    for j in range(0, 4) {
      result.data((i * 5) + j) = mask(i)(j);
    }
  }

  result
}

/* Generates a 5x1 filter data structure given its coefficients */
fn filter_5x1(mask : [f64 * 5]) -> filter_struct {
  /* Allocates the filter data structure for a 5x1 filter */
  let result = filter_struct {
    data: allocate_double_matrix(5, 1),
    size: 5
  };

  /* Stores the coefficients to the filter data */
  for i in range(0, 4) {
    result.data(i) = mask(i);
  }

  result
}

/* Apply 2D filter convolution with separable kernels (tiling) */
fn apply_2d_tiled_convolution(img : image_struct, mask : filter_struct) -> () {
  let anchor = mask.size / 2;

  /* Applies the filter in columns */
  for x, y in iterate(img) {
    let mut sum = 0.0;

    /* Checks image boundaries */
    if(x >= anchor && x < img.width - anchor) {
      for i in range(-anchor, anchor) {
        sum += mask.data(i + anchor) * get_pixel_real(img, x + i, y);
      }
    }

    set_buffer_pixel_real(img, x, y, sum);
  }

  /* Copies result from buffer to image data */
  sync_image_data(img);

  /* Applies the filter in rows */
  for x, y in iterate(img) {
    let mut sum = 0.0;

    /* Checks image boundaries */
    if(y >= anchor && y < img.height - anchor) {
      for i in range(-anchor, anchor) {
        sum += mask.data(i + anchor) * get_pixel_real(img, x, y + i);
      }
    }

    set_buffer_pixel_real(img, x, y, sum);
  }

  /* Copies result from buffer to image data */
  sync_image_data(img);
}

/* Apply 2D filter convolution with non-separable kernels (blocks) */
fn apply_2d_block_convolution(img : image_struct, mask : filter_struct) -> () {
  let anchor = mask.size / 2;

  /* Applies the filter in blocks */
  for x, y in iterate(img) {
    let mut sum = 0.0;

    /* Checks image boundaries */
    if(x >= anchor && x < img.width - anchor && y >= anchor && y <= img.height - anchor) {
      for i in range(-anchor, anchor) {
        for j in range(-anchor, anchor) {
          sum += mask.data(((i + anchor) * mask.size) + j + anchor) * get_pixel_real(img, x + i, y + j);
        }
      }

      set_buffer_pixel_real(img, x, y, sum);
    }
  }

  /* Copies result from buffer to image data */
  sync_image_data(img);
}

/* Gaussian filter */
fn gaussian_blur(img : image_struct) -> () {
  /* Generates the mask for non-separable Gaussian kernel (based on OpenCV source) */
  let mask = filter_5x1([0.0625, 0.25, 0.375, 0.25, 0.0625]);

  /* Applies the separable kernel in rows and columns */
  apply_2d_tiled_convolution(img, mask);
}

/* Sobel filter */
fn sobel(img : image_struct) -> () {
  for x, y in iterate(img) {
    let mut sum_x = 0.0;
    let mut sum_y = 0.0;

    if(x > 0 && x < img.width - 1 && y > 0 && y < img.height - 1) {
      sum_x += get_pixel_real(img, x - 1, y - 1);
      sum_x += get_pixel_real(img, x - 1, y    ) * 2.0;
      sum_x += get_pixel_real(img, x - 1, y + 1);
      sum_x -= get_pixel_real(img, x + 1, y - 1);
      sum_x -= get_pixel_real(img, x + 1, y    ) * 2.0;
      sum_x -= get_pixel_real(img, x + 1, y + 1);

      sum_y += get_pixel_real(img, x - 1, y - 1);
      sum_y += get_pixel_real(img, x,     y - 1) * 2.0;
      sum_y += get_pixel_real(img, x + 1, y - 1);
      sum_y -= get_pixel_real(img, x - 1, y + 1);
      sum_y -= get_pixel_real(img, x,     y + 1) * 2.0;
      sum_y -= get_pixel_real(img, x + 1, y + 1);

      img.directions(y * img.width + x) = atan2(sum_y, sum_x);
      set_buffer_pixel_real(img, x, y, sqrt(sum_x * sum_x + sum_y * sum_y));
    }
  }

  sync_image_data(img);
}

/* Non-maximum supression */
fn non_maximum_supression(img : image_struct) -> () {
  /* Offsets for the angles */
  let offsets = [[1, 0], [1, 1], [0, 1], [1, -1]];

  /* Copies image data to buffer */
  sync_image_buffer(img);

  /* Go through the image */
  for x, y in iterate(img) {
    let value = get_pixel(img, x, y);               /* Pixel value at (x, y) */
    let angle = img.directions(y * img.width + x);  /* Directions angle */
    let index = round_angle(angle);                 /* Angle index */
    let nb1_x = x + offsets(index)(0);              /* First neighboor x coordinate */
    let nb1_y = y + offsets(index)(1);              /* First neighboor y coordinate */
    let nb2_x = x - offsets(index)(0);              /* Second neighboor x coordinate */
    let nb2_y = y - offsets(index)(1);              /* Second neighboor y coordinate */
    let mut nb1_value = 0 as u8;                    /* First neighboor value */
    let mut nb2_value = 0 as u8;                    /* Second neighboor value */

    /* Checks if first neighboor's position is valid */
    if nb1_x >= 0 && nb1_x < img.width && nb1_y >= 0 && nb1_y < img.height {
      nb1_value = get_pixel(img, nb1_x, nb1_y);
    }

    /* Checks if second neighboor's position is valid */
    if nb2_x >= 0 && nb2_x < img.width && nb2_y >= 0 && nb2_y < img.height {
      nb2_value = get_pixel(img, nb2_x, nb2_y);
    }

    /* If the pixel value is less than one of the neighboors values, sets it to zero */
    if value < nb1_value || value < nb2_value {
      set_buffer_pixel(img, x, y, 0 as u8);
    }
  }

  /* Copy oper_buffer data to image data */
  sync_image_data(img);
}

/* Hysteresis */
fn hysteresis(img : image_struct) -> () {
  let low_threshold = 40 as u8;
  let high_threshold = low_threshold * (3 as u8);
  let mut counter = 1;

  /*
     Go through the image and sets pixel value according to the
     following conditions:

     If pixel value is in the [0,low_threshold] interval, it
     becomes 0 (not an edge)

     If pixel value is in the ]low_threshold,high_threshold] interval,
     it becomes 1 (weak edge)

     If pixel value is in the ]high_threshold, 255[ interval, it becomes
     15 (strong edge)
  */

  for x, y in iterate(img) {
    let value = get_pixel(img, x, y);

    if value < low_threshold {
      set_pixel(img, x, y, 0 as u8);
    } else if value < high_threshold {
      set_pixel(img, x, y, 1 as u8);
    } else {
      set_pixel(img, x, y, 15 as u8);
    }
  }

  /* Go through the image and looks for the weak edges to see if they
     have strong edges as neighboors, if that's the case, they are
     considered edges and are set as strong edges. This procedure is
     executed repeatedly until there are no more weak edges to be updated. */
  while counter > 0 {
    counter = 0;

    for x, y in iterate(img) {
      if get_pixel(img, x, y) == 1 as u8 {
        let mut sum = 0 as u8;

        if(x > 0 && x < img.width - 1 && y > 0 && y < img.height - 1) {
          for i in range(-1, 1) {
            for j in range(-1, 1) {
              sum += get_pixel(img, x + i, y + j);
            }
          }

          if sum >= 15 as u8 {
            counter = counter + 1;
            set_pixel(img, x, y, 15 as u8);
          }
        }
      }
    }
  }

  /* Sets strong edges pixels to 255 and other pixels to 0 to
     get the final result */
  for x, y in iterate(img) {
    if get_pixel(img, x, y) >= 15 as u8 {
      set_pixel(img, x, y, 255 as u8);
    } else {
      set_pixel(img, x, y, 0 as u8);
    }
  }
}

/* Canny */
fn canny(img : image_struct) -> () {
  //gaussian_blur(img);
  sobel(img);
  non_maximum_supression(img);
  hysteresis(img);
}

/* Compare the result with the reference (OpenCV Canny) and display
   the statistics */
fn compare_results(img : image_struct, reference : &mut[u8]) -> () {
  let mut corrects = 0;
  let mut false_positives = 0;
  let mut false_negatives = 0;

  for x, y in iterate(img) {
    let pixel_value = get_pixel(img, x, y) as i32;
    let pixel_reference = reference(y * img.width + x) as i32;

    set_pixel(img, x, y, 0 as u8);
    set_buffer_pixel(img, x, y, 0 as u8);

    if pixel_value != 0 {
      if pixel_reference != 0 {
        corrects++;
      } else {
        set_pixel(img, x, y, 255 as u8);
        false_positives++;
      }
    } else if pixel_reference != 0 {
      set_buffer_pixel(img, x, y, 255 as u8);
      false_negatives++;
    }
  }

  show_statistics(corrects, false_positives, false_negatives);
}
