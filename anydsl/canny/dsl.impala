struct image_struct {
  data : &mut[u8],
  oper_buffer : &mut[u8],
  directions : &mut[f64],
  width : i32,
  height : i32,
  loaded : bool
};

struct filter_struct {
  data : &mut[f64],
  size : i32,
};

extern "C" {
  /* Memory allocation functions */
  fn allocate_double_matrix(width : i32, height : i32) -> (&mut[f64]);
  fn allocate_uchar_matrix(width : i32, height : i32) -> (&mut[u8]);
  fn free_double_matrix(&mut[f64]) -> ();
  fn free_uchar_matrix(image : &[u8]) -> ();

  /* OpenCV functions */
  fn load_image(path : &[u8], width : &i32, height : &i32) -> (&mut[u8]);
  fn opencv_canny(threshold : u8, display : bool) -> (&mut[u8]);
  fn display_image(title : &[u8]) -> ();

  /* Printing functions */
  fn print_uchar_matrix(&[u8], width : i32, height : i32) -> ();
  fn print_integer(value : i32) -> ();
  fn show_statistics(corrects : i32, false_positives : i32, false_negatives : i32) -> ();
}

fn image(filename : &[u8]) -> image_struct {
  let mut res : image_struct;
  let pwidth = &mut res.width;
  let pheight = &mut res.height;

  res.data = load_image(filename, pwidth, pheight);
  res.oper_buffer = allocate_uchar_matrix(res.width, res.height);
  res.directions = allocate_double_matrix(res.width, res.height);
  res.loaded = true;

  res
}

fn generate_image(width : i32, height : i32) -> image_struct {
  let res = image_struct {
    data: allocate_uchar_matrix(width, height),
    oper_buffer: allocate_uchar_matrix(width, height),
    directions: allocate_double_matrix(width, height),
    width: width,
    height: height,
    loaded: false
  };

  for x, y in iterate(res) {
    set_pixel(res, x, y, (x + y) as u8);
  }

  res
}

fn print_image(img : image_struct) -> () {
  print_uchar_matrix(img.data, img.width, img.height);
}

fn destroy_image(img : image_struct) -> () {
  if !img.loaded {
    free_uchar_matrix(img.data);
  }

  free_uchar_matrix(img.oper_buffer);
  free_double_matrix(img.directions);
}

fn set_pixel(img : image_struct, x : i32, y : i32, value : u8) -> () {
  img.data(y * img.width + x) = value;
}

fn get_pixel(img : image_struct, x : i32, y : i32) -> (u8) {
  img.data(y * img.width + x)
}

fn set_pixel_real(img : image_struct, x : i32, y : i32, value : f64) -> () {
  img.data(y * img.width + x) = value as u8;
}

fn get_pixel_real(img : image_struct, x : i32, y : i32) -> (f64) {
  img.data(y * img.width + x) as f64
}

fn set_buffer_pixel(img : image_struct, x : i32, y : i32, value : u8) -> () {
  img.oper_buffer(y * img.width + x) = value;
}

fn get_buffer_pixel(img : image_struct, x : i32, y : i32) -> (u8) {
  img.oper_buffer(y * img.width + x)
}

fn set_buffer_pixel_real(img : image_struct, x : i32, y : i32, value : f64) -> () {
  img.oper_buffer(y * img.width + x) = value as u8;
}

fn get_buffer_pixel_real(img : image_struct, x : i32, y : i32) -> (f64) {
  img.oper_buffer(y * img.width + x) as f64
}

fn sync_image_data(img : image_struct) -> () {
  for x, y in iterate(img) {
    img.data(y * img.width + x) = img.oper_buffer(y * img.width + x);
  }
}

fn sync_image_buffer(img : image_struct) -> () {
  for x, y in iterate(img) {
    img.oper_buffer(y * img.width + x) = img.data(y * img.width + x);
  }
}

fn range(mut min : i32, max : i32, body : fn(int) -> ()) -> () {
  while min <= max {
    body(min);
    min++;
  }
}

fn filter_3x3(mask : [[f64 * 3] * 3]) -> filter_struct {
  let result = filter_struct {
    data: allocate_double_matrix(3, 3),
    size: 3
  };

  for i in range(0, 2) {
    for j in range(0, 2) {
      result.data((i * 3) + j) = mask(i)(j);
    }
  }

  result
}

fn filter_5x5(mask : [[f64 * 5] * 5]) -> filter_struct {
  let result = filter_struct {
    data: allocate_double_matrix(5, 5),
    size: 5
  };

  for i in range(0, 4) {
    for j in range(0, 4) {
      result.data((i * 5) + j) = mask(i)(j);
    }
  }

  result
}

fn filter_5x1(mask : [f64 * 5]) -> filter_struct {
  let result = filter_struct {
    data: allocate_double_matrix(5, 1),
    size: 5
  };

  for i in range(0, 4) {
    result.data(i) = mask(i);
  }

  result
}

fn apply_2d_tiled_convolution(img : image_struct, mask : filter_struct) -> () {
  let anchor = mask.size / 2;

  for x, y in iterate(img) {
    let mut sum = 0.0;

    if(x >= anchor && x < img.width - anchor) {
      for i in range(-anchor, anchor) {
        sum += mask.data(i + anchor) * get_pixel_real(img, x + i, y);
      }
    }

    set_buffer_pixel_real(img, x, y, sum);
  }

  sync_image_data(img);

  for x, y in iterate(img) {
    let mut sum = 0.0;

    if(y >= anchor && y < img.height - anchor) {
      for i in range(-anchor, anchor) {
        sum += mask.data(i + anchor) * get_pixel_real(img, x, y + i);
      }
    }

    set_buffer_pixel_real(img, x, y, sum);
  }

  sync_image_data(img);
}

fn apply_2d_block_convolution(img : image_struct, mask : filter_struct) -> () {
  let anchor = mask.size / 2;

  for x, y in iterate(img) {
    let mut sum = 0.0;

    if(x >= anchor && x < img.width - anchor && y >= anchor && y <= img.height - anchor) {
      for i in range(-anchor, anchor) {
        for j in range(-anchor, anchor) {
          sum += mask.data(((i + anchor) * mask.size) + j + anchor) * get_pixel_real(img, x + i, y + j);
        }
      }

      set_buffer_pixel_real(img, x, y, sum);
    }
  }

  sync_image_data(img);
}

fn gaussian_blur(img : image_struct) -> () {
  let mask = filter_5x1([0.0625, 0.25, 0.375, 0.25, 0.0625]);

  apply_2d_tiled_convolution(img, mask);
}

fn sobel(img : image_struct) -> () {
  let mask_x = [[-1.0,  0.0,  1.0],
                [-2.0,  0.0,  2.0],
                [-1.0,  0.0,  1.0]];

  let mask_y = [[-1.0, -2.0, -1.0],
                [0.0,   0.0,  0.0],
                [1.0,   2.0,  1.0]];

  let anchor = 3 / 2;

  for x, y in iterate(img) {
    let mut sum_x = 0.0;
    let mut sum_y = 0.0;

    if(x > 0 && x < img.width - 1 && y > 0 && y < img.height - 1) {
      for i in range(-anchor, anchor) {
        for j in range(-anchor, anchor) {
          let value = get_pixel_real(img, x + i, y + j);

          sum_x += mask_x(i + anchor)(j + anchor) * value;
          sum_y += mask_y(i + anchor)(j + anchor) * value;
        }
      }

      img.directions(y * img.width + x) = atan2(sum_y, sum_x);
      set_buffer_pixel_real(img, x, y, sqrt(sum_x * sum_x + sum_y * sum_y));
    }
  }

  sync_image_data(img);
}

fn degrees_to_radian(angle : f64) -> (f64) {
  angle * 3.14 / 180.0
}

fn round_angle(angle : f64) -> (i32) {
  (((fabs(angle) + 0.3926991) / 0.785398) as i32) % 4
}

fn non_maximum_supression(img : image_struct) -> () {
  let offsets = [[0, 1, 0, -1], [1, -1, -1, 1], [1, 0, -1, 0], [1, 1, -1, -1]];

  sync_image_buffer(img);

  for x, y in iterate(img) {
    let value = get_pixel(img, x, y);
    let angle_index = round_angle(img.directions(y * img.width + x));
    let nb1_x = x + offsets(angle_index)(0);
    let nb1_y = y + offsets(angle_index)(1);
    let nb2_x = x + offsets(angle_index)(2);
    let nb2_y = y + offsets(angle_index)(3);
    let mut nb1_value = 0 as u8;
    let mut nb2_value = 0 as u8;

    if nb1_x >= 0 && nb1_x < img.width && nb1_y >= 0 && nb1_y < img.height {
      nb1_value = get_pixel(img, nb1_x, nb1_y);
    }

    if nb2_x >= 0 && nb2_x < img.width && nb2_y >= 0 && nb2_y < img.height {
      nb2_value = get_pixel(img, nb2_x, nb2_y);
    }

    if value < nb1_value || value < nb2_value {
      set_buffer_pixel(img, x, y, 0 as u8);
    }
  }

  sync_image_data(img);
}

fn hysteresis(img : image_struct) -> () {
  let low_threshold = 40 as u8;
  let high_threshold = low_threshold * (3 as u8);
  let mut counter = 1;

  for x, y in iterate(img) {
    let value = get_pixel(img, x, y);

    if value < low_threshold {
      set_pixel(img, x, y, 0 as u8);
    } else if value < high_threshold {
      set_pixel(img, x, y, 1 as u8);
    } else {
      set_pixel(img, x, y, 15 as u8);
    }
  }

  while counter > 0 {
    counter = 0;

    for x, y in iterate(img) {
      if get_pixel(img, x, y) == 1 as u8 {
        let mut sum = 0 as u8;

        if(x > 0 && x < img.width - 1 && y > 0 && y < img.height - 1) {
          for i in range(-1, 1) {
            for j in range(-1, 1) {
              sum += get_pixel(img, x + i, y + j);
            }
          }

          if sum >= 15 as u8 {
            counter = counter + 1;
            set_pixel(img, x, y, 15 as u8);
          }
        }
      }
    }
  }

  for x, y in iterate(img) {
    if get_pixel(img, x, y) > 1 as u8 {
      set_pixel(img, x, y, 255 as u8);
    } else {
      set_pixel(img, x, y, 0 as u8);
    }
  }
}

fn canny(img : image_struct) -> () {
  gaussian_blur(img);
  sobel(img);
  non_maximum_supression(img);
  hysteresis(img);
}

fn compare_results(img : image_struct, reference : &mut[u8]) -> () {
  let mut corrects = 0;
  let mut false_positives = 0;
  let mut false_negatives = 0;

  for x, y in iterate(img) {
    let pixel_value = get_pixel(img, x, y) as i32;
    let pixel_reference = reference(y * img.width + x) as i32;

    if pixel_value != 0 {
      if pixel_reference != 0 {
        corrects++;
      } else {
        false_positives++;
      }
    } else if pixel_reference != 0 {
      false_negatives++;
    }
  }

  show_statistics(corrects, false_positives, false_negatives);
}
