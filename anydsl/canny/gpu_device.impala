fn grid_config(img : image_struct) -> (i32, i32, i32) {
  (img.width - (img.width % 256), img.height, 1)
}

fn block_config(img : image_struct) -> (i32, i32, i32) {
  (256, 4, 1)
}

/* Iterates over an image on GPU architectures */
fn fake_iterate(img : image_struct, body: fn(int,int) -> ()) -> () {
  let acc = cuda_accelerator(0);
  let grid = grid_config(img);
  let block = block_config(img);

  with acc.exec(grid, block) @{
    let x = acc.bidx() * acc.bdimx() + acc.tidx();
    let y = acc.bidy() * acc.bdimy() + acc.tidy();

    body(x, y);
  }
}

/* Serial iterate for use in case of data dependency issues */
fn serial_iterate(img : image_struct, body: fn(int, int) -> ()) -> () {
  let block_size = 20; /* Pixels per block */
  let offset = img.width * 2 + 5;

  for i in step_range(0, img.height - (block_size + 1), block_size) {
    for j in step_range(0, img.width - (block_size + 1), block_size) {
      for k in range(0, block_size - 1) {
        for l in range(0, block_size - 1) {
          let x = j + l + offset;
          let y = i + k;

          body(x, y);
        }
      }
    }
  }

  for i in range(img.width - block_size, img.width - 1) {
    for j in range(0, img.height - 1) {
      body(i + offset, j);
    }
  }

  for i in range(img.height - block_size, img.height - 1) {
    for j in range(0, img.width - (block_size + 1)) {
      body(j + offset, i);
    }
  }
}

/* Iterate for stencils */
fn stencil_iterate(
  img : image_struct,
  filter : filter_struct,
  buffer_to_data : bool,
  body: fn(int, int, Buffer, Buffer, Buffer) -> ()) -> () {

  let acc = cuda_accelerator(0);
  let grid = grid_config(img);
  let block = block_config(img);
  let size = (img.width + 2) * (img.height + 2) * sizeof[f64]();
  let offset = img.width * 2 + 5;

  let arr_in = acc.alloc(size);
  let arr_out = acc.alloc(size);
  let mask = acc.alloc(filter.size * sizeof[f64]());

  if buffer_to_data {
    copy(img.buffer, arr_in, size);
  } else {
    copy(img.data, arr_in, size);
  }

  copy(filter.data, mask, filter.size * sizeof[f64]());

  with acc.exec(grid, block) @{
    let x = acc.bidx() * acc.bdimx() + acc.tidx() + offset;
    let y = acc.bidy() * acc.bdimy() + acc.tidy();

    body(x, y, arr_in, arr_out, mask);
  }

  if buffer_to_data {
    copy(arr_out, img.data, size);
  } else {
    copy(arr_out, img.buffer, size);
  }

  release(arr_in);
  release(arr_out);
}

fn gradient_iterate(
  img : image_struct,
  buffer_to_data : bool,
  copy_magnitudes : bool,
  body: fn(int, int, Buffer, Buffer, Buffer, Buffer) -> ()) -> () {

  let acc = cuda_accelerator(0);
  let grid = grid_config(img);
  let block = block_config(img);
  let size = (img.width + 2) * (img.height + 2) * sizeof[f64]();
  let offset = img.width * 2 + 5;

  let arr_in = acc.alloc(size);
  let arr_out = acc.alloc(size);
  let dx = acc.alloc(size);
  let dy = acc.alloc(size);

  if buffer_to_data {
    copy(img.buffer, arr_in, size);
  } else {
    copy(img.data, arr_in, size);
  }

  if copy_magnitudes {
    copy(img.dx, dx, size);
    copy(img.dy, dy, size);
  }

  with acc.exec(grid, block) @{
    let x = acc.bidx() * acc.bdimx() + acc.tidx() + offset;
    let y = acc.bidy() * acc.bdimy() + acc.tidy();

    body(x, y, arr_in, arr_out, dx, dy);
  }

  if buffer_to_data {
    copy(arr_out, img.data, size);
  } else {
    copy(arr_out, img.buffer, size);
  }

  if !copy_magnitudes {
    copy(dx, img.dx, size);
    copy(dy, img.dy, size);
  }

  release(dx);
  release(dy);
  release(arr_in);
  release(arr_out);
}

fn read(buf: Buffer, i: i32) -> f64 {
  bitcast[&[1][f64]](buf.data)(i)
}

fn write(buf: Buffer, i: i32, v: f64) -> () {
  bitcast[&mut[1][f64]](buf.data)(i) = v
}

fn exp(a : f64) -> f64 {
  cuda_intrinsics.exp(a)
}
