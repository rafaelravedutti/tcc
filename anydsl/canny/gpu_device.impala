fn grid_config(img : image_struct) -> (i32, i32, i32) {
  (img.width, img.height, 1)
}

fn block_config(img : image_struct) -> (i32, i32, i32) {
  (16 - (img.width % 16), 1, 1)
}

/* Iterates over an image on GPU architectures */
fn iterate(img : image_struct, body: fn(int,int) -> ()) -> () {
  let acc = cuda_accelerator(0);
  let grid = grid_config(img);
  let block = block_config(img);

  with acc.exec(grid, block) @{
    let x = acc.bidx() * acc.bdimx() + acc.tidx();
    let y = acc.bidy() * acc.bdimy() + acc.tidy();

    body(x, y);
  }
}

fn stencil_iterate(
  img : image_struct,
  filter : filter_struct,
  buffer_to_data : bool,
  body: fn(int, int, Buffer, Buffer, Buffer) -> ()) -> () {

  let acc = cuda_accelerator(0);
  let grid = grid_config(img);
  let block = block_config(img);
  let size = (img.width + 2) * (img.height + 2) * sizeof[f64]();

  let arr_in = acc.alloc(size);
  let arr_out = acc.alloc(size);
  let mask = acc.alloc(filter.size * sizeof[f64]());

  if buffer_to_data {
    copy(img.extended_buffer, arr_in, size);
  } else {
    copy(img.extended_data, arr_in, size);
  }

  copy(filter.data, mask, filter.size * sizeof[f64]());

  with acc.exec(grid, block) @{
    let x = acc.bidx() * acc.bdimx() + acc.tidx() + img.width + 3;
    let y = acc.bidy() * acc.bdimy() + acc.tidy();

    body(x, y, arr_in, arr_out, mask);
  }

  if buffer_to_data {
    copy(arr_out, img.extended_data, size);
  } else {
    copy(arr_out, img.extended_buffer, size);
  }

  release(arr_in);
  release(arr_out);
}

fn sobel_iterate(
  img : image_struct,
  buffer_to_data : bool,
  body: fn(int, int, Buffer, Buffer, Buffer, Buffer) -> ()) -> () {

  let acc = cuda_accelerator(0);
  let grid = grid_config(img);
  let block = block_config(img);
  let size = (img.width + 2) * (img.height + 2) * sizeof[f64]();

  let arr_in = acc.alloc(size);
  let arr_out = acc.alloc(size);
  let dx = acc.alloc(size);
  let dy = acc.alloc(size);

  if buffer_to_data {
    copy(img.extended_buffer, arr_in, size);
  } else {
    copy(img.extended_data, arr_in, size);
  }

  with acc.exec(grid, block) @{
    let x = acc.bidx() * acc.bdimx() + acc.tidx() + img.width + 3;
    let y = acc.bidy() * acc.bdimy() + acc.tidy();

    body(x, y, arr_in, arr_out, dx, dy);
  }

  if buffer_to_data {
    copy(arr_out, img.extended_data, size);
  } else {
    copy(arr_out, img.extended_buffer, size);
  }

  copy(dx, img.dx, size);
  copy(dy, img.dy, size);

  release(dx);
  release(dy);
  release(arr_in);
  release(arr_out);
}

fn nms_iterate(
  img : image_struct,
  buffer_to_data : bool,
  body: fn(int, int, Buffer, Buffer, Buffer, Buffer, Buffer) -> ()) -> () {

  let acc = cuda_accelerator(0);
  let grid = grid_config(img);
  let block = block_config(img);
  let size = (img.width + 2) * (img.height + 2) * sizeof[f64]();

  let arr_in = acc.alloc(size);
  let arr_out = acc.alloc(size);
  let indexes = acc.alloc((img.width + 2) * (img.height + 2) * sizeof[i32]());
  let dx = acc.alloc(size);
  let dy = acc.alloc(size);

  if buffer_to_data {
    copy(img.extended_buffer, arr_in, size);
  } else {
    copy(img.extended_data, arr_in, size);
  }

  copy(img.dx, dx, size);
  copy(img.dy, dy, size);

  with acc.exec(grid, block) @{
    let x = acc.bidx() * acc.bdimx() + acc.tidx() + img.width + 3;
    let y = acc.bidy() * acc.bdimy() + acc.tidy();

    body(x, y, arr_in, arr_out, indexes, dx, dy);
  }

  if buffer_to_data {
    copy(arr_out, img.extended_data, size);
  } else {
    copy(arr_out, img.extended_buffer, size);
  }

  release(dx);
  release(dy);
  release(indexes);
  release(arr_in);
  release(arr_out);
}

fn read(buf: Buffer, i: i32) -> f64 {
  bitcast[&[1][f64]](buf.data)(i)
}

fn write(buf: Buffer, i: i32, v: f64) -> () {
  bitcast[&mut[1][f64]](buf.data)(i) = v
}

fn read_int(buf: Buffer, i: i32) -> i32 {
  bitcast[&[1][i32]](buf.data)(i)
}

fn write_int(buf: Buffer, i: i32, v: i32) -> () {
  bitcast[&mut[1][i32]](buf.data)(i) = v
}


fn exp(a : f64) -> f64 {
  cuda_intrinsics.exp(a)
}
