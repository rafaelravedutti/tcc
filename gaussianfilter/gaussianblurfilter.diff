0a1,10
> #include "hipacc_cu.hpp"
> 
> #include "cuGaussianBlurFilterMaskColumnGFCConst.cu"
> #include "cuGaussianBlurFilterMaskRowGFRM.cu"
> #include "cuGaussianBlurFilterMaskRowGFRR.cu"
> #include "cuGaussianBlurFilterMaskColumnGFCC.cu"
> #include "cuGaussianBlurFilterMaskRowGFRC.cu"
> #include "cuGaussianBlurFilterMaskRowGFRConst.cu"
> #include "cuGaussianBlurFilterMaskColumnGFCM.cu"
> #include "cuGaussianBlurFilterMaskColumnGFCR.cu"
44d53
< #include "hipacc.hpp"
58d66
< using namespace hipacc;
175,242d182
< class GaussianBlurFilterMaskRow : public Kernel<float> {
<     private:
<         Accessor<uchar> &input;
<         Mask<float> &mask;
<         const int size;
< 
<     public:
<         GaussianBlurFilterMaskRow(IterationSpace<float> &iter, Accessor<uchar>
<                 &input, Mask<float> &mask, const int size) :
<             Kernel(iter),
<             input(input),
<             mask(mask),
<             size(size)
<         { add_accessor(&input); }
< 
<         #ifdef USE_LAMBDA
<         void kernel() {
<             output() = convolve(mask, Reduce::SUM, [&] () -> float {
<                     return mask() * input(mask);
<                     });
<         }
<         #else
<         void kernel() {
<             const int anchor = size >> 1;
<             float sum = 0;
< 
<             for (int xf = -anchor; xf<=anchor; ++xf) {
<                 sum += mask(xf, 0) * input(xf, 0);
<             }
< 
<             output() = sum;
<         }
<         #endif
< };
< class GaussianBlurFilterMaskColumn : public Kernel<uchar> {
<     private:
<         Accessor<float> &input;
<         Mask<float> &mask;
<         const int size;
< 
<     public:
<         GaussianBlurFilterMaskColumn(IterationSpace<uchar> &iter,
<                 Accessor<float> &input, Mask<float> &mask, const int size) :
<             Kernel(iter),
<             input(input),
<             mask(mask),
<             size(size)
<         { add_accessor(&input); }
< 
<         #ifdef USE_LAMBDA
<         void kernel() {
<             output() = (uchar)(convolve(mask, Reduce::SUM, [&] () -> float {
<                     return mask() * input(mask);
<                     }) + 0.5f);
<         }
<         #else
<         void kernel() {
<             const int anchor = size >> 1;
<             float sum = 0.5f;
< 
<             for (int yf = -anchor; yf<=anchor; ++yf) {
<                 sum += mask(0, yf) * input(0, yf);
<             }
< 
<             output() = (uchar) (sum);
<         }
<         #endif
< };
249a190,191
>     hipaccInitCUDA();
>     
372,374c314,316
<     Image<uchar> IN(width, height, input);
<     Image<uchar> OUT(width, height);
<     Image<float> TMP(width, height);
---
>     HipaccImage IN = hipaccCreateMemory<uchar>(input, width, height, 256);
>     HipaccImage OUT = hipaccCreateMemory<uchar>(NULL, width, height, 256);
>     HipaccImage TMP = hipaccCreateMemory<float>(NULL, width, height, 256);
377,379c319,321
<     Mask<float> M(filter_xy);
<     Mask<float> MX(filter_x);
<     Mask<float> MY(filter_y);
---
>     
>     
>     
381,382c323,324
<     IterationSpace<uchar> IsOut(OUT);
<     IterationSpace<float> IsTmp(TMP);
---
>     HipaccAccessor IsOut(OUT);
>     HipaccAccessor IsTmp(TMP);
427,435c369,396
<     BoundaryCondition<uchar> BcInClamp(IN, MX, Boundary::CLAMP);
<     Accessor<uchar> AccInClamp(BcInClamp);
<     GaussianBlurFilterMaskRow GFRC(IsTmp, AccInClamp, MX, size_x);
< 
<     BoundaryCondition<float> BcTmpClamp(TMP, MY, Boundary::CLAMP);
<     Accessor<float> AccTmpClamp(BcTmpClamp);
<     GaussianBlurFilterMaskColumn GFCC(IsOut, AccTmpClamp, MY, size_y);
< 
<     GFRC.execute();
---
>     
>     HipaccAccessor AccInClamp(IN);
>     
> 
>     
>     HipaccAccessor AccTmpClamp(TMP);
>     
> 
>     hipacc_launch_info GFRC_info0(2, 0, IsTmp, 1, 1);
>     dim3 block0(128, 1);
>     dim3 grid0(hipaccCalcGridFromBlock(GFRC_info0, block0));
> 
>     hipaccPrepareKernelLaunch(GFRC_info0, block0);
>     hipaccConfigureCall(grid0, block0);
> 
>     size_t offset0 = 0;
>     hipaccSetupArgument(&IsTmp.img.mem, sizeof(float *), offset0);
>     hipaccSetupArgument(&IsTmp.width, sizeof(const int), offset0);
>     hipaccSetupArgument(&IsTmp.img.stride, sizeof(const int), offset0);
>     hipaccSetupArgument(&AccInClamp.img.mem, sizeof(uchar *), offset0);
>     hipaccSetupArgument(&AccInClamp.width, sizeof(const int), offset0);
>     hipaccSetupArgument(&AccInClamp.height, sizeof(const int), offset0);
>     hipaccSetupArgument(&AccInClamp.img.stride, sizeof(const int), offset0);
>     hipaccSetupArgument(&GFRC_info0.bh_start_left, sizeof(const int), offset0);
>     hipaccSetupArgument(&GFRC_info0.bh_start_right, sizeof(const int), offset0);
>     hipaccSetupArgument(&GFRC_info0.bh_fall_back, sizeof(const int), offset0);
>     
>     hipaccLaunchKernel((const void *)&cuGaussianBlurFilterMaskRowGFRCKernel, "cuGaussianBlurFilterMaskRowGFRCKernel", grid0, block0);
437c398,418
<     GFCC.execute();
---
>     hipacc_launch_info GFCC_info0(0, 2, IsOut, 1, 1);
>     dim3 block1(128, 1);
>     dim3 grid1(hipaccCalcGridFromBlock(GFCC_info0, block1));
> 
>     hipaccPrepareKernelLaunch(GFCC_info0, block1);
>     hipaccConfigureCall(grid1, block1);
> 
>     size_t offset1 = 0;
>     hipaccSetupArgument(&IsOut.img.mem, sizeof(uchar *), offset1);
>     hipaccSetupArgument(&IsOut.width, sizeof(const int), offset1);
>     hipaccSetupArgument(&IsOut.img.stride, sizeof(const int), offset1);
>     hipaccSetupArgument(&AccTmpClamp.img.mem, sizeof(float *), offset1);
>     hipaccSetupArgument(&AccTmpClamp.width, sizeof(const int), offset1);
>     hipaccSetupArgument(&AccTmpClamp.height, sizeof(const int), offset1);
>     hipaccSetupArgument(&AccTmpClamp.img.stride, sizeof(const int), offset1);
>     hipaccSetupArgument(&GFCC_info0.bh_start_right, sizeof(const int), offset1);
>     hipaccSetupArgument(&GFCC_info0.bh_start_top, sizeof(const int), offset1);
>     hipaccSetupArgument(&GFCC_info0.bh_start_bottom, sizeof(const int), offset1);
>     hipaccSetupArgument(&GFCC_info0.bh_fall_back, sizeof(const int), offset1);
>     
>     hipaccLaunchKernel((const void *)&cuGaussianBlurFilterMaskColumnGFCCKernel, "cuGaussianBlurFilterMaskColumnGFCCKernel", grid1, block1);
453,461c434,461
<     BoundaryCondition<uchar> BcInRepeat(IN, MX, Boundary::REPEAT);
<     Accessor<uchar> AccInRepeat(BcInRepeat);
<     GaussianBlurFilterMaskRow GFRR(IsTmp, AccInRepeat, MX, size_x);
< 
<     BoundaryCondition<float> BcTmpRepeat(TMP, MY, Boundary::REPEAT);
<     Accessor<float> AccTmpRepeat(BcTmpRepeat);
<     GaussianBlurFilterMaskColumn GFCR(IsOut, AccTmpRepeat, MY, size_y);
< 
<     GFRR.execute();
---
>     
>     HipaccAccessor AccInRepeat(IN);
>     
> 
>     
>     HipaccAccessor AccTmpRepeat(TMP);
>     
> 
>     hipacc_launch_info GFRR_info0(2, 0, IsTmp, 1, 1);
>     dim3 block2(128, 1);
>     dim3 grid2(hipaccCalcGridFromBlock(GFRR_info0, block2));
> 
>     hipaccPrepareKernelLaunch(GFRR_info0, block2);
>     hipaccConfigureCall(grid2, block2);
> 
>     size_t offset2 = 0;
>     hipaccSetupArgument(&IsTmp.img.mem, sizeof(float *), offset2);
>     hipaccSetupArgument(&IsTmp.width, sizeof(const int), offset2);
>     hipaccSetupArgument(&IsTmp.img.stride, sizeof(const int), offset2);
>     hipaccSetupArgument(&AccInRepeat.img.mem, sizeof(uchar *), offset2);
>     hipaccSetupArgument(&AccInRepeat.width, sizeof(const int), offset2);
>     hipaccSetupArgument(&AccInRepeat.height, sizeof(const int), offset2);
>     hipaccSetupArgument(&AccInRepeat.img.stride, sizeof(const int), offset2);
>     hipaccSetupArgument(&GFRR_info0.bh_start_left, sizeof(const int), offset2);
>     hipaccSetupArgument(&GFRR_info0.bh_start_right, sizeof(const int), offset2);
>     hipaccSetupArgument(&GFRR_info0.bh_fall_back, sizeof(const int), offset2);
>     
>     hipaccLaunchKernel((const void *)&cuGaussianBlurFilterMaskRowGFRRKernel, "cuGaussianBlurFilterMaskRowGFRRKernel", grid2, block2);
463c463,483
<     GFCR.execute();
---
>     hipacc_launch_info GFCR_info0(0, 2, IsOut, 1, 1);
>     dim3 block3(128, 1);
>     dim3 grid3(hipaccCalcGridFromBlock(GFCR_info0, block3));
> 
>     hipaccPrepareKernelLaunch(GFCR_info0, block3);
>     hipaccConfigureCall(grid3, block3);
> 
>     size_t offset3 = 0;
>     hipaccSetupArgument(&IsOut.img.mem, sizeof(uchar *), offset3);
>     hipaccSetupArgument(&IsOut.width, sizeof(const int), offset3);
>     hipaccSetupArgument(&IsOut.img.stride, sizeof(const int), offset3);
>     hipaccSetupArgument(&AccTmpRepeat.img.mem, sizeof(float *), offset3);
>     hipaccSetupArgument(&AccTmpRepeat.width, sizeof(const int), offset3);
>     hipaccSetupArgument(&AccTmpRepeat.height, sizeof(const int), offset3);
>     hipaccSetupArgument(&AccTmpRepeat.img.stride, sizeof(const int), offset3);
>     hipaccSetupArgument(&GFCR_info0.bh_start_right, sizeof(const int), offset3);
>     hipaccSetupArgument(&GFCR_info0.bh_start_top, sizeof(const int), offset3);
>     hipaccSetupArgument(&GFCR_info0.bh_start_bottom, sizeof(const int), offset3);
>     hipaccSetupArgument(&GFCR_info0.bh_fall_back, sizeof(const int), offset3);
>     
>     hipaccLaunchKernel((const void *)&cuGaussianBlurFilterMaskColumnGFCRKernel, "cuGaussianBlurFilterMaskColumnGFCRKernel", grid3, block3);
479,487c499,526
<     BoundaryCondition<uchar> BcInMirror(IN, MX, Boundary::MIRROR);
<     Accessor<uchar> AccInMirror(BcInMirror);
<     GaussianBlurFilterMaskRow GFRM(IsTmp, AccInMirror, MX, size_x);
< 
<     BoundaryCondition<float> BcTmpMirror(TMP, MY, Boundary::MIRROR);
<     Accessor<float> AccTmpMirror(BcTmpMirror);
<     GaussianBlurFilterMaskColumn GFCM(IsOut, AccTmpMirror, MY, size_y);
< 
<     GFRM.execute();
---
>     
>     HipaccAccessor AccInMirror(IN);
>     
> 
>     
>     HipaccAccessor AccTmpMirror(TMP);
>     
> 
>     hipacc_launch_info GFRM_info0(2, 0, IsTmp, 1, 1);
>     dim3 block4(128, 1);
>     dim3 grid4(hipaccCalcGridFromBlock(GFRM_info0, block4));
> 
>     hipaccPrepareKernelLaunch(GFRM_info0, block4);
>     hipaccConfigureCall(grid4, block4);
> 
>     size_t offset4 = 0;
>     hipaccSetupArgument(&IsTmp.img.mem, sizeof(float *), offset4);
>     hipaccSetupArgument(&IsTmp.width, sizeof(const int), offset4);
>     hipaccSetupArgument(&IsTmp.img.stride, sizeof(const int), offset4);
>     hipaccSetupArgument(&AccInMirror.img.mem, sizeof(uchar *), offset4);
>     hipaccSetupArgument(&AccInMirror.width, sizeof(const int), offset4);
>     hipaccSetupArgument(&AccInMirror.height, sizeof(const int), offset4);
>     hipaccSetupArgument(&AccInMirror.img.stride, sizeof(const int), offset4);
>     hipaccSetupArgument(&GFRM_info0.bh_start_left, sizeof(const int), offset4);
>     hipaccSetupArgument(&GFRM_info0.bh_start_right, sizeof(const int), offset4);
>     hipaccSetupArgument(&GFRM_info0.bh_fall_back, sizeof(const int), offset4);
>     
>     hipaccLaunchKernel((const void *)&cuGaussianBlurFilterMaskRowGFRMKernel, "cuGaussianBlurFilterMaskRowGFRMKernel", grid4, block4);
489c528,548
<     GFCM.execute();
---
>     hipacc_launch_info GFCM_info0(0, 2, IsOut, 1, 1);
>     dim3 block5(128, 1);
>     dim3 grid5(hipaccCalcGridFromBlock(GFCM_info0, block5));
> 
>     hipaccPrepareKernelLaunch(GFCM_info0, block5);
>     hipaccConfigureCall(grid5, block5);
> 
>     size_t offset5 = 0;
>     hipaccSetupArgument(&IsOut.img.mem, sizeof(uchar *), offset5);
>     hipaccSetupArgument(&IsOut.width, sizeof(const int), offset5);
>     hipaccSetupArgument(&IsOut.img.stride, sizeof(const int), offset5);
>     hipaccSetupArgument(&AccTmpMirror.img.mem, sizeof(float *), offset5);
>     hipaccSetupArgument(&AccTmpMirror.width, sizeof(const int), offset5);
>     hipaccSetupArgument(&AccTmpMirror.height, sizeof(const int), offset5);
>     hipaccSetupArgument(&AccTmpMirror.img.stride, sizeof(const int), offset5);
>     hipaccSetupArgument(&GFCM_info0.bh_start_right, sizeof(const int), offset5);
>     hipaccSetupArgument(&GFCM_info0.bh_start_top, sizeof(const int), offset5);
>     hipaccSetupArgument(&GFCM_info0.bh_start_bottom, sizeof(const int), offset5);
>     hipaccSetupArgument(&GFCM_info0.bh_fall_back, sizeof(const int), offset5);
>     
>     hipaccLaunchKernel((const void *)&cuGaussianBlurFilterMaskColumnGFCMKernel, "cuGaussianBlurFilterMaskColumnGFCMKernel", grid5, block5);
505,513c564,591
<     BoundaryCondition<uchar> BcInConst(IN, MX, Boundary::CONSTANT, '1');
<     Accessor<uchar> AccInConst(BcInConst);
<     GaussianBlurFilterMaskRow GFRConst(IsTmp, AccInConst, MX, size_x);
< 
<     BoundaryCondition<float> BcTmpConst(TMP, MY, Boundary::CONSTANT, 1.0f);
<     Accessor<float> AccTmpConst(BcTmpConst);
<     GaussianBlurFilterMaskColumn GFCConst(IsOut, AccTmpConst, MY, size_y);
< 
<     GFRConst.execute();
---
>     
>     HipaccAccessor AccInConst(IN);
>     
> 
>     
>     HipaccAccessor AccTmpConst(TMP);
>     
> 
>     hipacc_launch_info GFRConst_info0(2, 0, IsTmp, 1, 1);
>     dim3 block6(128, 1);
>     dim3 grid6(hipaccCalcGridFromBlock(GFRConst_info0, block6));
> 
>     hipaccPrepareKernelLaunch(GFRConst_info0, block6);
>     hipaccConfigureCall(grid6, block6);
> 
>     size_t offset6 = 0;
>     hipaccSetupArgument(&IsTmp.img.mem, sizeof(float *), offset6);
>     hipaccSetupArgument(&IsTmp.width, sizeof(const int), offset6);
>     hipaccSetupArgument(&IsTmp.img.stride, sizeof(const int), offset6);
>     hipaccSetupArgument(&AccInConst.img.mem, sizeof(uchar *), offset6);
>     hipaccSetupArgument(&AccInConst.width, sizeof(const int), offset6);
>     hipaccSetupArgument(&AccInConst.height, sizeof(const int), offset6);
>     hipaccSetupArgument(&AccInConst.img.stride, sizeof(const int), offset6);
>     hipaccSetupArgument(&GFRConst_info0.bh_start_left, sizeof(const int), offset6);
>     hipaccSetupArgument(&GFRConst_info0.bh_start_right, sizeof(const int), offset6);
>     hipaccSetupArgument(&GFRConst_info0.bh_fall_back, sizeof(const int), offset6);
>     
>     hipaccLaunchKernel((const void *)&cuGaussianBlurFilterMaskRowGFRConstKernel, "cuGaussianBlurFilterMaskRowGFRConstKernel", grid6, block6);
515c593,613
<     GFCConst.execute();
---
>     hipacc_launch_info GFCConst_info0(0, 2, IsOut, 1, 1);
>     dim3 block7(128, 1);
>     dim3 grid7(hipaccCalcGridFromBlock(GFCConst_info0, block7));
> 
>     hipaccPrepareKernelLaunch(GFCConst_info0, block7);
>     hipaccConfigureCall(grid7, block7);
> 
>     size_t offset7 = 0;
>     hipaccSetupArgument(&IsOut.img.mem, sizeof(uchar *), offset7);
>     hipaccSetupArgument(&IsOut.width, sizeof(const int), offset7);
>     hipaccSetupArgument(&IsOut.img.stride, sizeof(const int), offset7);
>     hipaccSetupArgument(&AccTmpConst.img.mem, sizeof(float *), offset7);
>     hipaccSetupArgument(&AccTmpConst.width, sizeof(const int), offset7);
>     hipaccSetupArgument(&AccTmpConst.height, sizeof(const int), offset7);
>     hipaccSetupArgument(&AccTmpConst.img.stride, sizeof(const int), offset7);
>     hipaccSetupArgument(&GFCConst_info0.bh_start_right, sizeof(const int), offset7);
>     hipaccSetupArgument(&GFCConst_info0.bh_start_top, sizeof(const int), offset7);
>     hipaccSetupArgument(&GFCConst_info0.bh_start_bottom, sizeof(const int), offset7);
>     hipaccSetupArgument(&GFCConst_info0.bh_fall_back, sizeof(const int), offset7);
>     
>     hipaccLaunchKernel((const void *)&cuGaussianBlurFilterMaskColumnGFCConstKernel, "cuGaussianBlurFilterMaskColumnGFCConstKernel", grid7, block7);
523c621
<     uchar *output = OUT.data();
---
>     uchar *output = hipaccReadMemory<uchar>(OUT);
710a809,811
>     hipaccReleaseMemory(OUT);
>     hipaccReleaseMemory(IN);
>     hipaccReleaseMemory(TMP);
